<!doctype html>

<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Python Objects - Object-Oriented Programming</title>
        <link href="/support/web/supplemental.css" rel="stylesheet" type="text/css" />

        <meta
            property="og:title"
            content="Python Objects - Master Object-Oriented Programming"
        />
        <meta property="og:type" content="article" />
        <meta
            property="og:description"
            content="Learn object-oriented programming by building interactive graphics simulations with Python classes. Create bouncing balls and explore object behavior."
        />
        <meta
            property="og:url"
            content="https://mooc.interactivedatascience.courses/labs/python_objects.html"
        />
        <meta
            property="og:image"
            content="https://mooc.interactivedatascience.courses/support/web/card.jpg"
        />

        <meta
            name="twitter:title"
            content="Python Objects - Master Object-Oriented Programming"
        />
        <meta
            name="twitter:description"
            content="Learn object-oriented programming by building interactive graphics simulations with Python classes. Create bouncing balls and explore object behavior."
        />
        <meta
            name="twitter:image"
            content="https://mooc.interactivedatascience.courses/support/web/card.jpg"
        />
        <meta name="twitter:card" content="summary_large_image" />
    </head>
    <body>
        <div class="skip-link">
            <a href="#main">Skip to content</a>
        </div>
        <header>
            This tutorial is part of the <a href="/labs">skills labs</a> within
            <a href="/">Interactive Data Science and Visualization</a>.
        </header>
        <main id="main">
            <h1>Python Objects</h1>
            In this tutorial, we will build a graphical interactive simulation
            through object-oriented programming.

            <details>
                <summary>Contents</summary>
                <ul>
                    <li><a href="#recap">Recap</a></li>
                    <li><a href="#exercise">Exercise</a></li>
                    <li><a href="#classes">Classes</a></li>
                    <li><a href="#sketch">Sketch</a></li>
                    <li><a href="#ball">Ball</a></li>
                    <li><a href="#motion">Motion</a></li>
                    <li><a href="#simulation">Simulation</a></li>
                    <li><a href="#draw">Draw</a></li>
                    <li><a href="#mouse">Mouse</a></li>
                    <li><a href="#interacting">Interacting</a></li>
                    <li><a href="#cleanup">Cleanup</a></li>
                    <li><a href="#next">Next</a></li>
                </ul>
            </details>

            <section id="recap">
                <h2>Recap</h2>

                In our <a href="/labs/python_intro.html">first tutorial</a>, we
                introduced the idea that computer programs are like empty
                worlds. To populate those worlds, we can give names to numbers
                and text. We can breathe life into those objects by defining the
                rules that dictate their behavior. However, our programs did not
                know about much else on its own beyond what a number is and how
                to do arithmetic with it. In other words, the types of objects
                we could build were limited. In the
                <a href="/labs/python_graphics.html">second tutorial</a>, we
                brought in libraries to make these worlds graphical by leaning
                on the work of other developers that came before us. This let us
                make new types of things even if we were constrained by what
                those prior developers imagined. Finaly, this tutorial explores
                how we can tell the computer about new concepts and how we can
                use that power to create interactive simulations.
            </section>

            <section id="exercise">
                <h2>Exercise</h2>

                We will build a simulation in which balls rush out across the
                screen, bouncing off the edges once they reach the ends of the
                sketch. This will demonstrate how to tell the computer about new
                things and how they behave. Additionally, we will let the user
                interact with these balls with the mouse. In each of these
                steps, we will have the computer draw the full path that these
                balls take, creating branch-like structures across the screen.
            </section>

            <section id="classes">
                <h2>Classes</h2>

                <p>
                    To tell the computer about a new type of thing, we create a
                    class. Specifically, we will make a class for the balls
                    which are bouncing around and a simulation which tracks all
                    of those balls.
                </p>

                <details>
                    <summary>About classes</summary>
                    <div>
                        <p>
                            A class is like the blueprint or the DNA for
                            something (which we call objects). It says what
                            properties (which we call fields) define that
                            something and what behaviors (which we call methods)
                            we can expect from that thing. Here, behaviors mean
                            things that the objects can do or have be done to
                            them. You can think of fields as variables bound to
                            an object and methods as functions tied to an
                            object. Let's explore an example conceptually before
                            actually building a class for a ball.
                        </p>

                        <p>
                            For this conceptual example, let's return to bank
                            accounts from the first tutorial. It may have fields
                            like owner, balance, and interest rate. These
                            properties define the bank account, offering the
                            information needed for each bank account to
                            function. It may have methods like withdraw,
                            deposit, and give_interest. If we make a BankAccount
                            class, you might have a bank account and I might
                            have a bank account. Each individual bank account is
                            said to be an "instance" of the BankAccount class
                            and each one would have its own owner, balance, and
                            interest rate.
                        </p>

                        <p>
                            We will make our own class in just a moment but, to
                            learn more about classes, see
                            <a href="https://python.swaroopch.com/oop.html"
                                >A Byte of Python</a
                            >.
                        </p>
                    </div>
                </details>
            </section>

            <section id="sketch">
                <h2>Sketch</h2>

                Let's start by making a sketch.

                <pre>
import sketchingpy
import time

WIDTH = 500  # pixels
HEIGHT = 400  # pixels

sketch = sketchingpy.Sketch2D(WIDTH, HEIGHT)
</pre
                >

                Here, Sketch2D is a class and sketch is an instance.

                <details>
                    <summary>About comments and constants</summary>
                    <p>
                        The # refers to a comment as we might have seen in prior
                        example code (anything on the line of code after # is
                        ignored by the computer). We also see some variables in
                        all caps. We call these constants and, by putting it in
                        all caps, we signal to other developers that the value
                        of these variables should not change over time
                    </p>
                </details>
            </section>

            <section id="ball">
                <h2>Defining a Ball</h2>

                Let's make our first class. Our ball will have an x and y
                position on screen. This ball will also be in motion. We will
                define that movement through velocity as pixels per second in
                the x and y direction. One important method is called "__init__"
                which is called when an instance is first made.

                <pre>
class Ball:

    def __init__(self, position_x, position_y, velocity_x, velocity_y):
        self.position_x = position_x
        self.position_y = position_y
        self.velocity_x = velocity_x
        self.velocity_y = velocity_y</pre
                >

                This snippet creates the concept of a ball. When that ball is
                made, we ask for the position and velocity. Finally, within the
                __init__ method, we create the following fields: position_x,
                position_y, velocity_x, and velocity_y. Remember self from the
                <a href="/labs/python_graphics.html">previous tutorial</a>? Now
                we can see now why it is used: the self parameter refers to the
                instance. By using this parameter, we can manipulate variables
                tied to that individual instance like position_x.

                <details>
                    <summary>More about self</summary>
                    <p>
                        Note that we don't pass self to the method. A parameter
                        value for self is inserted behind the scenes by Python.
                        In other words, the first parameter to every method is
                        always the instance. By convention, the vast majority of
                        Python developers call that parameter self. While you
                        can technically use whatever name you would like, self
                        is very strongly recommended.
                    </p>
                </details>
            </section>

            <section id="motion">
                <h2>Moving a Ball</h2>

                Now that we have created the fields on a ball, let's define its
                behaviors. The ball will "bounce" by reversing its x and / or y
                velocities. Starting with that:

                <pre>
class Ball:

    def __init__(self, position_x, position_y, velocity_x, velocity_y):
        self.position_x = position_x
        self.position_y = position_y
        self.velocity_x = velocity_x
        self.velocity_y = velocity_y

    def reverse_x(self):
        self.velocity_x = self.velocity_x * -1

    def reverse_y(self):
        self.velocity_y = self.velocity_y * -1</pre
                >

                If we had a ball, we could now call ball.reverse_x() to reverse
                its horizontal direction. Anyway, with that in mind, we now have
                all the pieces needed to make a method which updates the
                position of the ball on each step:

                <pre>
    def update(self, duration):
        self.position_x = self.position_x + self.velocity_x * duration
        self.position_y = self.position_y + self.velocity_y * duration

        if self.position_x > WIDTH:
            self.position_x = WIDTH
            self.reverse_x()
        elif self.position_x < 0:
            self.position_x = 0
            self.reverse_x()

        if self.position_y > HEIGHT:
            self.position_y = HEIGHT
            self.reverse_y()
        elif self.position_y < 0:
            self.position_y = 0
            self.reverse_y()</pre
                >

                We will call update on each ball for each step within our
                simulation.

                <details>
                    <summary>About offscreen</summary>
                    <p>
                        Note that our if statements are checking if the ball has
                        fallen offscreen. Developers and designers have been
                        thinking hard for a long time about what to do when this
                        happens. Sometimes, folks will have an object falling
                        offscreen appear at the opposite side of the world. This
                        is like how one's position on a map continues moving
                        right as you move west until you reach the edge but, as
                        the Earth is round, you wouldn't fall off but simply
                        would appear on the other side of the map. This is
                        called wrapping. For us, we simply have the ball bounce
                        off the edges. This is an "in-bounds" behavior that
                        imagines that nothing exists past the edge of our flat
                        coordinate system.
                    </p>
                </details>
            </section>

            <section id="simulation">
                <h2>Defining a Simulation</h2>

                It is common to make a class for an overall simulation as well.
                This can be used to keep track of time and the different
                instances that make up the simulated world.

                <pre>
class Simulation:

    def __init__(self):
        self.balls = [
            Ball(WIDTH / 2, HEIGHT / 2, -10, -10),
            Ball(WIDTH / 2, HEIGHT / 2, -10, 10),
            Ball(WIDTH / 2, HEIGHT / 2, 10, 0)
        ]
        self.last_time = time.time()
</pre
                >

                Notice how we are making three instances of the Ball class.
                Let's also add an update method to the Simulation class which
                updates each of those balls using a loop.

                <pre>
    def update(self):
        new_time = time.time()
        duration = new_time - self.last_time
        self.last_time = new_time

        for ball in self.balls:
            ball.update(duration)</pre
                >

                Now, we have everything we need to simulate this system. In the
                next step, we will draw the state of the system after updating
                it.
            </section>

            <section id="draw">
                <h2>Draw the System</h2>

                We are simulating the system but we haven't yet made it visible.
                Let's go ahead and create a new simulation and register a
                function to call on each step of the sketch:

                <pre>
simulation = Simulation()

def update_and_draw_balls(self):
    simulation.update()
    for ball in simulation.balls:
        sketch.draw_ellipse(ball.position_x, ball.position_y, 2, 2)

sketch.on_step(update_and_draw_balls)
sketch.show()</pre
                >

                Here's some
                <a href="https://sketchingpy.org/reference/draw_ellipse.html"
                    >more info about draw_ellipse</a
                >. Need some help?
                <a
                    href="https://gist.github.com/sampottinger/49e6c897eae12c4a3e7bf161d80fc22b"
                    >Here's what my code looks like</a
                >. Anyway, let's go ahead and let this run. Try also changing
                the initial velocities of the balls or their starting positions.
                How does that change the patterns displayed to the user?
            </section>

            <section id="mouse">
                <h2>Get the Mouse</h2>

                Next, we want the user to be able to interact with the
                simulation through the mouse. For this, we need to route that
                information to each Ball instance. Let's start by updating the
                on_step callback:

                <pre>
def update_and_draw_balls(self):
    mouse = sketch.get_mouse()
    mouse_x = mouse.get_pointer_x()
    mouse_y = mouse.get_pointer_y()

    simulation.update(mouse_x, mouse_y)

    for ball in simulation.balls:
        sketch.draw_ellipse(ball.position_x, ball.position_y, 2, 2)</pre
                >

                Next, we need to update the simulation (the Simulation class) to
                take that information:

                <pre>
    def update(self, mouse_x, mouse_y):
        new_time = time.time()
        duration = new_time - self.last_time
        self.last_time = new_time

        for ball in self.balls:
            ball.update(duration, mouse_x, mouse_y)</pre
                >

                Finally, we need to have the Ball class understand how to
                respond. This will take a little bit of thinking.
            </section>

            <section id="interacting">
                <h2>Interacting with the Mouse</h2>

                At a high level, we want to see if the mouse is near the ball.
                If it is, we then change the x velocity if the ball bounces
                against the cursor horizontally or we change the y velocity if
                the ball bounces against the cursor vertically. Let's start by
                writing out this high level logic by changing the Ball's update
                method:

                <pre>
    def update(self, duration, mouse_x, mouse_y):
        self.position_x = self.position_x + self.velocity_x * duration
        self.position_y = self.position_y + self.velocity_y * duration

        if self.position_x > WIDTH:
            self.position_x = WIDTH
            self.reverse_x()
        elif self.position_x < 0:
            self.position_x = 0
            self.reverse_x()

        if self.position_y > HEIGHT:
            self.position_y = HEIGHT
            self.reverse_y()
        elif self.position_y < 0:
            self.position_y = 0
            self.reverse_y()

        if self.get_is_near_mouse(mouse_x, mouse_y):
            if self.get_hit_mouse_in_direction(self.position_x, mouse_x, self.velocity_x):
                self.reverse_x()
            elif self.get_hit_mouse_in_direction(self.position_y, mouse_y, self.velocity_y):
                self.reverse_y()</pre
                >

                This code provides a translation of our thoughts in English to
                our thoughts in Python. However, there are a few items missing.
                Let's start by adding a new method in Ball called
                get_is_near_mouse:

                <pre>
    def get_is_near_mouse(self, mouse_x, mouse_y):
        x_near = abs(mouse_x - self.position_x) < 10
        y_near = abs(mouse_y - self.position_y) < 10
        return x_near and y_near</pre
                >

                Here we are using a function that is built into Python called
                abs which returns the absolute value of a number. If the ball is
                within 10 pixels, we say that it has collided with the cursor
                and we check in which direction the velocity should change. For
                that, let's add a new method called get_hit_mouse_in_direction:

                <pre>
    def get_hit_mouse_in_direction(self, coordinate, mouse, velocity):
        if mouse > coordinate and velocity > 0:
            distance = mouse - coordinate
            return distance < 10
        elif mouse < coordinate and velocity < 0:
            distance = mouse - coordinate
            return distance > -10
        else:
            return False</pre
                >

                This function allows us to check if the mouse was hit along a
                certain axis. Both if statements see if the mouse was moving
                towards the cursor in the given direction and then we return
                True or False depending on if the ball was close along that
                given axis.
            </section>

            <section id="cleanup">
                <h2>Cleaning Up</h2>

                <p>
                    Go ahead and give this a run if you haven't already. Need
                    help?
                    <a
                        href="https://gist.github.com/sampottinger/856a833761a3ee2c8fdec4f7a53babcb"
                        >Here is what my file looks like after adding mouse
                        interaction</a
                    >. Before we conclude, there's a few things we need to
                    discuss as you will likely see them in Python code from
                    other developers.
                </p>

                <p>
                    First, if I were writing this code for my job, I would have
                    said self._position_x instead of self.position_x. This
                    leading underscore tells other developers not to modify that
                    value directly and to, instead, access it through the
                    methods of class. We say that we are indicating that
                    position_x is a "private" field. Similarly, there are some
                    methods that I would make private as they are only used
                    internally within the object like self._reverse_x instead of
                    self.reverse_x.
                </p>

                <details>
                    <summary>Why private attributes</summary>

                    <p>
                        Some developers think that all fields should be private
                        such that changes to variables on an instance can only
                        happen through public methods (those without a leading
                        underscore). To understand why, let's return to the
                        example of BankAccount. Maybe changes to the balance
                        require other actions like sending the owner a note.
                        Specifically, imagine that we need to inform the owner
                        by text each time money is withdrawn. Of course, we
                        could add that logic to the withdraw method. However,
                        what if a developer using the BankAccount class started
                        doing account.balance = account.balance + 10? That extra
                        logic within the withdraw method wouldn't execute if
                        someone accessed balance directly. In this case, we want
                        to make balance private to ensure developers go through
                        the methods of the class.
                    </p>
                </details>

                <p>
                    Many developers typically make things private by default and
                    then decide which select methods should be public. This
                    dictates how code outside the object should interact with
                    each instance. We say that this is defining an "interface"
                    that is used "publicly" outside the object. This ensure all
                    of the actions that need to happen are taken care of as the
                    fields or "state" of the object changes over time. We can do
                    this for our simulation too. What would you make private?
                    Note that this concept is called
                    <a
                        href="https://medium.com/@heyamit10/encapsulation-in-object-oriented-programming-f10ed08c2998"
                        >encapsulation</a
                    >.
                </p>

                <p>
                    Second, I want to discuss what """ does. This defines a
                    special kind of comment called a
                    <a
                        href="https://www.datacamp.com/tutorial/docstrings-python"
                        >docstring</a
                    >
                    which tells another developer that this is an important
                    comment that defines how to use a file, a class, a function,
                    or a method. Some code editors can also take advantage of
                    these docstrings to help provide contextual information
                    while you program.
                </p>

                <p>
                    All of this in mind, please see this
                    <a
                        href="https://gist.github.com/sampottinger/9813a8604fa20a2f764c41d989ac599c"
                        >final version of our code</a
                    >
                    which is how I would have written it for my job.
                </p>
            </section>

            <section id="next">
                <h2>Next: Lecture</h2>

                We've reached the end of our first set of skills labs! If you
                are taking the course with me during the semester, please note
                that lectures (and recordings) will go back to normal for a bit
                instead of using the flipped format. So, there won't be a
                recording sent out ahead of our next class time. If you are
                doing this on your own time, you can return to the lectures or
                continue onwards to
                <a href="/labs/features_form.html">Skills Lab 4</a>.

                <details>
                    <summary>Citations</summary>
                    <ul>
                        <li>
                            C. Swaroop, A Byte of Python. 2024. [Online].
                            Available:
                            <a
                                href="https://python.swaroopch.com"
                                target="_blank"
                                >https://python.swaroopch.com</a
                            >
                        </li>
                        <li>
                            A. Pottinger, "Sketchingpy." Sketchingpy Project,
                            2024. [Online]. Available:
                            <a href="https://sketchingpy.org/" target="_blank"
                                >https://sketchingpy.org/</a
                            >
                        </li>
                        <li>
                            A. Sharma, "Docstrings in Python Tutorial."
                            Datacamp, Dec. 20, 2022. [Online]. Available:
                            <a
                                href="https://www.datacamp.com/tutorial/docstrings-python"
                                target="_blank"
                                >https://www.datacamp.com/tutorial/docstrings-python</a
                            >
                        </li>
                        <li>
                            H. Amit, "Encapsulation in Object-Oriented
                            Programming." Meidum, Nov. 19, 2024. [Online].
                            Available:
                            <a
                                href="https://medium.com/@heyamit10/encapsulation-in-object-oriented-programming-f10ed08c2998"
                                target="_blank"
                                >https://medium.com/@heyamit10/encapsulation-in-object-oriented-programming-f10ed08c2998</a
                            >
                        </li>
                    </ul>
                </details>
            </section>
        </main>
        <footer>
            Materials on this page are available under
            <a href="https://opensource.org/license/bsd-3-clause"
                >BSD 3-Clause License</a
            >
            for code and
            <a href="https://creativecommons.org/licenses/by/4.0/"
                >CC-BY License</a
            >
            for all other material. Thank you to
            <a href="https://public-sans.digital.gov">PublicSans</a> under the
            Open Font License. No cookies are used. Analytics limited to
            standard server logging which may collect IP addresses. These logs
            are deleted or anonymized within 30 days.
        </footer>
    </body>
</html>
